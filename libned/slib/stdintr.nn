import stdfn

intr add_same_intr<fwidth ofw, fwidth lfw, fwidth rfw, int *shape>(tensor<lfw, *shape> left, tensor<rfw, *shape> right):
    tensor<ofw, *shape> out
    return out

intr add_scalar_right_intr<fwidth ofw, fwidth lfw, fwidth rfw, int* shape>(tensor<lfw, *shape> left, tensor<rfw> right):
    tensor<ofw, *shape> out
    return out

intr sub_same_intr<fwidth ofw, fwidth lfw, fwidth rfw, int *shape>(tensor<lfw, *shape> left, tensor<rfw, *shape> right):
    tensor<ofw, *shape> out
    return out

intr sub_scalar_right_intr<fwidth ofw, fwidth lfw, fwidth rfw, int* shape>(tensor<lfw, *shape> left, tensor<rfw> right):
    tensor<ofw, *shape> out
    return out

intr sub_scalar_left_intr<fwidth ofw, fwidth lfw, fwidth rfw, int *shape>(tensor<lfw> left, tensor<rfw, *shape> right):
    tensor<*shape> out
    return out

intr mul_same_intr<fwidth ofw, fwidth lfw, fwidth rfw, int *shape>(tensor<lfw, *shape> left, tensor<rfw, *shape> right):
    tensor<ofw, *shape> out
    return out

intr mul_scalar_intr<fwidth ofw, fwidth lfw, fwidth rfw, int *shape>(tensor<lfw, *shape> left, tensor<rfw> right):
    tensor<ofw, *shape> out
    return out

intr div_same_intr<fwidth ofw, fwidth lfw, fwidth rfw, int *shape>(tensor<lfw, *shape> left, tensor<rfw, *shape> right):
    tensor<ofw, *shape> out
    return out

intr div_scalar_right_intr<fwidth ofw, fwidth lfw, fwidth rfw, int *shape>(tensor<lfw, *shape> left, tensor<rfw> right):
    tensor<ofw, *shape> out
    return out

intr div_scalar_left_intr<fwidth ofw, fwidth lfw, fwidth rfw, int *shape>(tensor<lfw>, tensor<rfw, *shape> right):
    tensor<ofw, *shape> out
    return out

intr matmul_intr<fwidth ofw, fwidth lfw, fwidth rfw, int M, int S, int N>(tensor<lfw, M, S> left, tensor<rfw, S, N> right):
    tensor<ofw, M, N> out
    return out

intr matvec_intr<fwidth ofw, fwidth lfw, fwidth rfw, int M, int N>(tensor<lfw, M, N> left, tensor<rfw, N> right):
    tensor<ofw, M> out
    return out

intr permute_intr<int *indicies, fwidth fw, <int *shape>>(tensor<fw, *shape> inp):
    if indicies.length >= shape.length:
        raise "Too many permutation indicies for input tensor rank"
    array<bool, shape.length> givens
    for int i in range(indicies.length):
        int idx = indicies[i]
        if idx < 0 or idx >= shape.length:
            raise "Index out of bounds for the given tensor"
        if givens[idx]:
            raise "Repeated index"
        givens[idx] = true

    array<int, shape.length> complete_indicies
    for int i in range(indicies.length):
        complete_indicies[i] = indicies[i]
    int ind_offset = indicies.length
    for int i in range(shape.length):
        if not givens[i]:
            complete_indicies[ind_offset] = i
            ind_offset += 1
    if ind_offset != shape.length:
        raise "I don't even know what happened here, I think this should be an assert"
    
    array<int, shape.length> new_shape
    for int i in range(shape.length):
        new_shape[i] = shape[complete_indicies[i]]
    tensor<fw, *new_shape> out
    return out
